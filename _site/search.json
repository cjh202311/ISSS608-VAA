[
  {
    "objectID": "In-class_Ex/In-class_Ex01/In-class_Ex01.html",
    "href": "In-class_Ex/In-class_Ex01/In-class_Ex01.html",
    "title": "In-class Exercise 1: Now you see it!",
    "section": "",
    "text": "In this hands-on exercise, two R packages will be used. They are:\n\ntidyverse\nhaven\n\nThe code chunk is as follows:\n\n\nCode\npacman::p_load(tidyverse,haven,dplyr)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex01/In-class_Ex01.html#loading-r-packages",
    "href": "In-class_Ex/In-class_Ex01/In-class_Ex01.html#loading-r-packages",
    "title": "In-class Exercise 1: Now you see it!",
    "section": "",
    "text": "In this hands-on exercise, two R packages will be used. They are:\n\ntidyverse\nhaven\n\nThe code chunk is as follows:\n\n\nCode\npacman::p_load(tidyverse,haven,dplyr)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex01/In-class_Ex01.html#importing-pisa-data",
    "href": "In-class_Ex/In-class_Ex01/In-class_Ex01.html#importing-pisa-data",
    "title": "In-class Exercise 1: Now you see it!",
    "section": "2 Importing PISA data",
    "text": "2 Importing PISA data\nThe code chunk below uses ‘read_sas()’ of haven to import PISA data into R environment.\n\n\nCode\nstu_qqq &lt;- haven::read_sas(\"data/cy08msp_stu_qqq.sas7bdat\")\n\n\n\n\nCode\nstu_qqq_SG &lt;- stu_qqq %&gt;%\n  filter(CNT == \"SGP\")\n\n\n\n\nCode\nwrite_rds(stu_qqq_SG,\n          \"data/stu_qqq_SG.rds\")\n\n\n\n\nCode\nstu_qqq_SG &lt;-\n  read_rds(\"data/stu_qqq_SG.rds\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex07/In-class_Ex7.html",
    "href": "In-class_Ex/In-class_Ex07/In-class_Ex7.html",
    "title": "In Class Exerice 7: IsoMap",
    "section": "",
    "text": "isohyet map is a surface map of the same precipitation: rain, snow, and others. Figure below is an isohyet map showing to spatial distribution of total monthly rainfall of Singapore in February 2024.\n\nIn order to prepare an isohyet map, spatial interpolation will be used. Spatial interpolation is the process of using points with known values to estimate values at other unknown points. For example, to make a rainfall above, we will not find enough evenly spread weather stations to cover the entire region. Spatial interpolation can estimate the rainfall at locations without recorded data by using known rainfall readings at nearby weather stations (see figure_temperature_map). This type of interpolated surface is often called a geostatistical surface. Elevation data, temperature, property prices, air quality index and population density are other types of data that can be computed using interpolation.\nThere are many interpolation methods. In this hands-on exercise, two widely used spatial interpolation methods called Inverse Distance Weighting (IDW) and kriging will be introduce. If you are looking for additional interpolation methods, please refer to the ‘Further Reading’ section at the end of this topic."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#over-view",
    "href": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#over-view",
    "title": "In Class Exerice 7: IsoMap",
    "section": "",
    "text": "isohyet map is a surface map of the same precipitation: rain, snow, and others. Figure below is an isohyet map showing to spatial distribution of total monthly rainfall of Singapore in February 2024.\n\nIn order to prepare an isohyet map, spatial interpolation will be used. Spatial interpolation is the process of using points with known values to estimate values at other unknown points. For example, to make a rainfall above, we will not find enough evenly spread weather stations to cover the entire region. Spatial interpolation can estimate the rainfall at locations without recorded data by using known rainfall readings at nearby weather stations (see figure_temperature_map). This type of interpolated surface is often called a geostatistical surface. Elevation data, temperature, property prices, air quality index and population density are other types of data that can be computed using interpolation.\nThere are many interpolation methods. In this hands-on exercise, two widely used spatial interpolation methods called Inverse Distance Weighting (IDW) and kriging will be introduce. If you are looking for additional interpolation methods, please refer to the ‘Further Reading’ section at the end of this topic."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#getting-started",
    "href": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#getting-started",
    "title": "In Class Exerice 7: IsoMap",
    "section": "2 Getting Started",
    "text": "2 Getting Started\nIn this in-class exercise, beside tidyverse, viridis, sf and tmap libaries, two new R packages will be used, they are:\n\nterra is a replacement of the raster package. It has a very similar, but simpler, interface, and it is faster than raster. In this hands-on exercise, it will be used to create grid (also known as raster) objects as the input and output of spatial interpolation.\ngstat, an r packages for spatial and spatio-temporal geostatistical modelling, prediction and simulation. In this in-class exercise, it will be used to perform spatial interpolation.\nautomap, an r package for performing automatic variogram modelling and kriging interpolation."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#the-data",
    "href": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#the-data",
    "title": "In Class Exerice 7: IsoMap",
    "section": "3 The Data",
    "text": "3 The Data\nThree data sets will be used in this exercise, they are:\n\nRainfallStation.csv provides location information of existing rainfall stations in Singapore. The data is downloaded from Meteological Service Singapore.\nDAILYDATA_202402.csv provides weather data are rainfall stations for the month February, 2024. The data is also downloaded from Meteological Service Singapore.\nMPSZ-2019 contains planning subzone boundary of URA Master Plan 2019. It is downloaded from data.gov.sg. The original data is in kml format.\n\n\n3.1 Importing rainfall station data\nIn the code chunk below, read_csv() of readr package is used to import RainfallStation.csv. rfstations, the output object is in tibble data.frame format.\n\n\n3.2 Importing rainfall record data\nIn the code chunk below, read_csv() of readr package is used to import DAILYDATA_202402.csv. rfdata, the output object is in tibble data.frame format.\n\n\n\n\n\n\nNote\n\n\n\n\nselect() of dplyr package is used to retain column 1 and 5 of the input data.\ngroup_by() and summarise() of dplyr package are used to compute the total monthly rainfall from Daily Rainfall Total (mm) field. The output is stored in a new field called MONTHSUM.\n\n\n\n\n\n3.3 Converting aspatial data into geospatial data\nNext, left_join() of dplyr is used to join rfstations to rfdata by using the code chunk below.\n\n\n\n\n\n\nNote\n\n\n\nBecause Station field is available in both rfstations and rfdata, by() argument of left_join() is not needed.\n\n\nIn the code chunk below, st_as_sf() of sf package is used to convert rfdata into a simple feature data.frame object called rfdata_sf.\n\n\n\n\n\n\nNote\n\n\n\n\nFor coords argument, it is important to map the X (i.e. Longitude) first, then follow by the Y (i.e. Latitude).\ncrs = 4326 indicates that the source data is in wgs84 coordinates system.\nst_transform() of sf package is then used to transform the source data from wgs84 to svy21 projected coordinates system.\nsvy21 is the official projected coordinates of Singapore. 3414 is the EPSG code of svy21.\n\n\n\n\n\n3.4 Importing planning subzone boundary data\nIn the code chunk below, st_read() of sf package is used to import MPSZ-2019 shapefile into R. The output is called mpsz2019. It is in polygon feature tibble data.frame format.\n\n\nReading layer `MPSZ-2019' from data source \n  `C:\\cjh202311\\ISSS608-VAA\\In-class_Ex\\In-class_Ex07\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nThe source data is in wgs84 coordinates system, hence st_tranform() of sf package is used to theo output sf data.frame into svy21 project coordinates system.\n\n\n\n\n\n3.5 Visualising the data prepared\nIt is always a good practice to visualise the data prepared. In the code chunk below, tmap functions are used to create a dot map showing locations of rainfall station in Singapore.\n\n\n\n\n\n\n\nIn the code chunk below, tmap functions are used to create a quantitative dot map of rainfall distribution by rainfall station in Singaspore"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#spatial-interpolation-gstat-method",
    "href": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#spatial-interpolation-gstat-method",
    "title": "In Class Exerice 7: IsoMap",
    "section": "4 Spatial Interpolation: gstat method",
    "text": "4 Spatial Interpolation: gstat method\nIn this section, you will gain hands-on experience on performing spatial interpolation by using gstat package. In order to perform spatial interpolation by using gstat, we first need to create an object of class called gstat, using a function of the same name: gstat. A gstat object contains all necessary information to conduct spatial interpolation, namely:\n\nThe model definition\nThe calibration data\n\nBased on its arguments, the gstat function “understands” what type of interpolation model we want to use:\n\nNo variogram model → IDW\nVariogram model, no covariates → Ordinary Kriging\nVariogram model, with covariates → Universal Kriging\n\nThe complete decision tree of gstat, including several additional methods which we are not going to use, is shown in the figure below.\n\n\n4.1 Data preparation\nTo getting start, we need create a grid data object by using rast() of terra package as shown in the cod chunk below.\n\n\n            x        y\n[1,] 2692.528 50231.33\n[2,] 2742.509 50231.33\n[3,] 2792.489 50231.33\n[4,] 2842.469 50231.33\n[5,] 2892.450 50231.33\n[6,] 2942.430 50231.33\n\n\n\n\n\n\n\n\nNote\n\n\n\nxyFromCell() gets coordinates of the center of raster cells for a row, column, or cell number of a SpatRaster. Or get row, column, or cell numbers from coordinates or from each other.\n\n\nLastly, we will create a data frame called coop with prediction/simulation locations by using the code chunk below.\n\n\nSimple feature collection with 6 features and 0 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 25883.42 ymin: 50231.33 xmax: 26133.32 ymax: 50231.33\nProjected CRS: SVY21 / Singapore TM\n                   geometry\n1 POINT (25883.42 50231.33)\n2  POINT (25933.4 50231.33)\n3 POINT (25983.38 50231.33)\n4 POINT (26033.36 50231.33)\n5 POINT (26083.34 50231.33)\n6 POINT (26133.32 50231.33)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#inverse-distance-weighted-idw",
    "href": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#inverse-distance-weighted-idw",
    "title": "In Class Exerice 7: IsoMap",
    "section": "5 Inverse Distance Weighted (IDW)",
    "text": "5 Inverse Distance Weighted (IDW)\n\n5.1 The method\nIn the IDW interpolation method, the sample points are weighted during interpolation such that the influence of one point relative to another declines with distance from the unknown point you want to create.\n\nWeighting is assigned to sample points through the use of a weighting coefficient that controls how the weighting influence will drop off as the distance from new point increases. The greater the weighting coefficient, the less the effect points will have if they are far from the unknown point during the interpolation process. As the coefficient increases, the value of the unknown point approaches the value of the nearest observational point.\nIt is important to notice that the IDW interpolation method also has some disadvantages: the quality of the interpolation result can decrease, if the distribution of sample data points is uneven. Furthermore, maximum and minimum values in the interpolated surface can only occur at sample data points. This often results in small peaks and pits around the sample data points.\n\n\n5.2 Working with gstat\nWe are going to use three parameters of the gstat function:\n\nformula: The prediction “formula” specifying the dependent and the independent variables (covariates)\ndata: The calibration data\nmodel: The variogram model\n\nKeep in mind that we need to specify parameter names, because these three parameters are not the first three in the gstat function definition.\nFor example, to interpolate using the IDW method we create the following gstat object, specifying just the formula and data:\ng = gstat(formula = annual ~ 1, data = rainfall)\n\n\n\n\n\n\nTip\n\n\n\nIn R, formula objects are used to specify relation between objects, in particular—the role of different data columns in statistical models. A formula object is created using the ~ operator, which separates names of dependent variables (to the left of the ~ symbol) and independent variables (to the right of the ~ symbol). Writing 1 to the right of the ~ symbol, as in ~ 1, means that there are no independent variables38.\n\n\nIn the code chunk below,\n\n\n\n\n\n\nImportant\n\n\n\nSpatial interpolation is not a rocket science, students should try to explore the method by changing nmax argument in order to understand how the final surface map will be affected by different nmax values.\n\n\nNow that our model is defined, we can use predict() to actually interpolate, i.e., to calculate predicted values. The predict function accepts:\n\nA raster—stars object, such as dem\nA model—gstat object, such as g\n\nThe raster serves for two purposes:\n\nSpecifying the locations where we want to make predictions (in all methods), and\nSpecifying covariate values (in Universal Kriging only).\n\n\n\n[inverse distance weighted interpolation]\n\n\nNow, we will map the interpolated surface by using tmap functions as shown in the code chunk below."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#kriging",
    "href": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#kriging",
    "title": "In Class Exerice 7: IsoMap",
    "section": "6 Kriging",
    "text": "6 Kriging\n\n6.1 The method\nKriging is one of several methods that use a limited set of sampled data points to estimate the value of a variable over a continuous spatial field. An example of a value that varies across a random spatial field might be total monthly rainfall over Singapore. It differs from Inverse Distance Weighted Interpolation discussed earlier in that it uses the spatial correlation between sampled points to interpolate the values in the spatial field: the interpolation is based on the spatial arrangement of the empirical observations, rather than on a presumed model of spatial distribution. Kriging also generates estimates of the uncertainty surrounding each interpolated value.\nIn a general sense, the kriging weights are calculated such that points nearby to the location of interest are given more weight than those farther away. Clustering of points is also taken into account, so that clusters of points are weighted less heavily (in effect, they contain less information than single points). This helps to reduce bias in the predictions.\nThe kriging predictor is an “optimal linear predictor” and an exact interpolator, meaning that each interpolated value is calculated to minimize the prediction error for that point. The value that is generated from the kriging process for any actually sampled location will be equal to the observed value at this point, and all the interpolated values will be the Best Linear Unbiased Predictors (BLUPs).\nKriging will in general not be more effective than simpler methods of interpolation if there is little spatial autocorrelation among the sampled data points (that is, if the values do not co-vary in space). If there is at least moderate spatial autocorrelation, however, kriging can be a helpful method to preserve spatial variability that would be lost using a simpler method (for an example, see Auchincloss 2007, below).\nKriging can be understood as a two-step process:\n\nfirst, the spatial covariance structure of the sampled points is determined by fitting a variogram; and\nsecond, weights derived from this covariance structure are used to interpolate values for unsampled points or blocks across the spatial field.\n\nKriging methods require a variogram model. A variogram (sometimes called a “semivariogram”) is a visual depiction of the covariance exhibited between each pair of points in the sampled data. For each pair of points in the sampled data, the gamma-value or “semi-variance” (a measure of the half mean-squared difference between their values) is plotted against the distance, or “lag”, between them. The “experimental” variogram is the plot of observed values, while the “theoretical” or “model” variogram is the distributional model that best fits the data.\n\n\n\n6.2 Working with gstat\nFirstly, we will calculate and examine the empirical variogram by using variogram() of gstat package. The function requires two arguments:\n\nformula, the dependent variable and the covariates (same as in gstat, see Section 12.2.1)\ndata, a point layer with the dependent variable and covariates as attributes\n\nas shown in the code chunk below.\n\n\n\n\n\nWe can then compare the plot with the theoretical models below.\n\nWith reference to the comparison above, am empirical variogram model will be fitted by using fit.variogram() of gstat package as shown in the code chunk below.\n\n\n  model     psill    range\n1   Nug 0.1129190    0.000\n2   Sph 0.5292397 5213.396\n\n\n\n\n\n\n\n\nImportant\n\n\n\nSpatial interpolation is not a rocket science, students should try to explore the method by changing psill, model, range, nugget arguments in order to understand how the final surface map will be affected by different options used.\n\n\nWe can visualise how well the observed data fit the model by plotting fv using the code chunk below.\n\n\n\n\n\nThe plot above reveals that the empirical model fits rather well. In view of this, we will go ahead to perform spatial interpolation by using the newly derived model as shown in the code chunk below.\n\n\ndata:\nvar1 : formula = MONTHSUM`~`1 ; data dim = 43 x 2\nvariograms:\n        model     psill    range\nvar1[1]   Nug 0.1129190    0.000\nvar1[2]   Sph 0.5292397 5213.396\n\n\nOnce we are happy with the results, predict() of gstat package will be used to estimate the unknown grids by using the code chunk below.\n\n\n[using ordinary kriging]\n\n\n\n\nSimple feature collection with 314019 features and 5 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2692.528 ymin: 15773.73 xmax: 56371.45 ymax: 50231.33\nProjected CRS: SVY21 / Singapore TM\nFirst 10 features:\n   var1.pred  var1.var                  geometry        x        y     pred\n1   131.0667 0.6608399 POINT (25883.42 50231.33) 25883.42 50231.33 131.0667\n2   130.9986 0.6610337  POINT (25933.4 50231.33) 25933.40 50231.33 130.9986\n3   130.9330 0.6612129 POINT (25983.38 50231.33) 25983.38 50231.33 130.9330\n4   130.8698 0.6613782 POINT (26033.36 50231.33) 26033.36 50231.33 130.8698\n5   130.8092 0.6615303 POINT (26083.34 50231.33) 26083.34 50231.33 130.8092\n6   130.7514 0.6616697 POINT (26133.32 50231.33) 26133.32 50231.33 130.7514\n7   130.6965 0.6617971  POINT (26183.3 50231.33) 26183.30 50231.33 130.6965\n8   130.6446 0.6619131 POINT (26233.28 50231.33) 26233.28 50231.33 130.6446\n9   130.5958 0.6620184 POINT (26283.26 50231.33) 26283.26 50231.33 130.5958\n10  132.5484 0.6542154 POINT (25033.76 50181.32) 25033.76 50181.32 132.5484\n\n\n\n\n\n\n\n\nNote\n\n\n\nresp is a sf tibble data.frame with point features.\n\n\nIn order to create a raster surface data object, rasterize() of terra is used as shown in the code chunk below.\n\n\nclass       : SpatRaster \ndimensions  : 690, 1075, 1  (nrow, ncol, nlyr)\nresolution  : 49.98037, 50.01103  (x, y)\nextent      : 2667.538, 56396.44, 15748.72, 50256.33  (xmin, xmax, ymin, ymax)\ncoord. ref. : SVY21 / Singapore TM (EPSG:3414) \nsource(s)   : memory\nname        :      last \nmin value   :  72.77826 \nmax value   : 195.53284 \n\n\n\n\n\n\n\n\nNote\n\n\n\nThe output object kpred is in SpatRaster object class with a spatial resolution of 50m x 50m. It consists of 1075 columns and 690 rows and in SVY21 projected coordinates system.\n\n\n\n\n6.3 Mapping the interpolated rainfall raster\nFinally, tmap functions are used to map the interpolated rainfall raster (i.e. kpred) by using the code chunk below.\n\n\n\n\n\n\n\n6.4 Automatic variogram modelling\nBeside using gstat to perform variogram modelling manually, autofirVariogram() of automap package can be used to perform varigram modelling as shown in the code chunk below.\n\n\n\n\n\n\n\n$exp_var\n   np      dist     gamma dir.hor dir.ver   id\n1  15  1957.436  311.9613       0       0 var1\n2  33  3307.349  707.7685       0       0 var1\n3  54  4861.368  848.1314       0       0 var1\n4 116  6716.531  730.3969       0       0 var1\n5 111  9235.708 1006.5381       0       0 var1\n6 120 11730.199 1167.5988       0       0 var1\n7 135 14384.636 1533.5903       0       0 var1\n\n$var_model\n  model    psill   range kappa\n1   Nug     0.00       0   0.0\n2   Ste 24100.71 1647955   0.3\n\n$sserr\n[1] 0.2178294\n\nattr(,\"class\")\n[1] \"autofitVariogram\" \"list\"            \n\n\n\n\ndata:\nvar1 : formula = MONTHSUM`~`1 ; data dim = 43 x 2\nvariograms:\n        model    psill   range kappa\nvar1[1]   Nug     0.00       0   0.0\nvar1[2]   Ste 24100.71 1647955   0.3\n\n\n\n\n[using ordinary kriging]"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#reference",
    "href": "In-class_Ex/In-class_Ex07/In-class_Ex7.html#reference",
    "title": "In Class Exerice 7: IsoMap",
    "section": "7 Reference",
    "text": "7 Reference\nOlea, Ricardo A. (2006-07) “A six-step practical approach to semivariogram modeling”, Stochastic Environmental Research and Risk Assessment, 2006-07, Vol.20 (5), p.307-318. SMU e-journal."
  }
]